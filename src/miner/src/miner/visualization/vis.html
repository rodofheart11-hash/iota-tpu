<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Activity Timeline</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111827;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const GanttChart = () => {
            const [events, setEvents] = useState([]);
            const [countLogs, setCountLogs] = useState([]);
            const [availableHotkeys, setAvailableHotkeys] = useState([]);
            const [selectedHotkey, setSelectedHotkey] = useState('');
            const [isLoading, setIsLoading] = useState(true);
            const [lastUpdate, setLastUpdate] = useState(null);
            const [error, setError] = useState(null);
            const [currentTime, setCurrentTime] = useState(0);
            const [autoRefresh, setAutoRefresh] = useState(true);
            const [isPaused, setIsPaused] = useState(false);
            const [windowSize, setWindowSize] = useState(20);
            const [timerNames, setTimerNames] = useState([]);
            const [tooltip, setTooltip] = useState({ visible: false, x: 0, y: 0, content: '' });

            // Track when we started the visualization (independent of data)
            const visualizationStartTimeRef = useRef(null);
            const pausedAtRef = useRef(null);
            const totalPausedTimeRef = useRef(0);
            const animationFrameRef = useRef(null);

            // Track the data's time offset
            const dataStartTimeRef = useRef(null);

            // Fetch timer names once on mount
            useEffect(() => {
                const fetchTimerNames = async () => {
                    try {
                        const response = await fetch('/api/timer_names');
                        if (response.ok) {
                            const names = await response.json();
                            setTimerNames(names);
                            console.log('Loaded timer names:', names);
                        }
                    } catch (e) {
                        console.log('Could not load timer names:', e);
                    }
                };
                fetchTimerNames();
            }, []);

            useEffect(() => {
                const scanHotkeys = async () => {
                    try {
                        const response = await fetch('/api/hotkeys');
                        if (response.ok) {
                            const hotkeys = await response.json();
                            if (hotkeys.length > 0) {
                                setAvailableHotkeys(hotkeys);
                                if (!selectedHotkey || !hotkeys.includes(selectedHotkey)) {
                                    setSelectedHotkey(hotkeys[0]);
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Could not load hotkeys:', err);
                    }
                };

                scanHotkeys();
                const interval = setInterval(scanHotkeys, 2000);
                return () => clearInterval(interval);
            }, [selectedHotkey]);

            useEffect(() => {
                if (!selectedHotkey || !autoRefresh) return;

                const fetchData = async () => {
                    try {
                        // Fetch events from API
                        const eventsResponse = await fetch(`/api/events/${selectedHotkey}`);
                        if (!eventsResponse.ok) {
                            throw new Error('Failed to load events');
                        }

                        const newEvents = await eventsResponse.json();
                        setEvents(newEvents);

                        // Fetch count logs from API
                        try {
                            const countsResponse = await fetch(`/api/counts/${selectedHotkey}`);
                            if (countsResponse.ok) {
                                const newCountLogs = await countsResponse.json();
                                setCountLogs(newCountLogs);
                            }
                        } catch (countErr) {
                            // Count logs might not exist yet, that's okay
                            console.log('Count logs not available yet:', countErr);
                        }

                        setLastUpdate(new Date().toLocaleTimeString());
                        setError(null);
                        setIsLoading(false);
                    } catch (err) {
                        setError(err.message);
                        setIsLoading(false);
                    }
                };

                fetchData();
                const interval = setInterval(fetchData, 500);
                return () => clearInterval(interval);
            }, [selectedHotkey, autoRefresh]);

            const activities = React.useMemo(() => {
                const activityMap = new Map();

                events.forEach(event => {
                    if (event.type === 'start') {
                        activityMap.set(event.id, {
                            id: event.id,
                            name: event.name,
                            metadata: event.metadata,
                            start_time: event.time,
                            end_time: null,
                            duration: null
                        });
                    } else if (event.type === 'end') {
                        const activity = activityMap.get(event.id);
                        if (activity) {
                            activity.end_time = event.time;
                            activity.duration = event.duration;
                        }
                    }
                });

                return Array.from(activityMap.values())
                    .filter(a => a.end_time !== null)
                    .sort((a, b) => a.start_time - b.start_time);
            }, [events]);

            const minTime = activities.length > 0 ? Math.min(...activities.map(d => d.start_time)) : 0;
            const maxTime = activities.length > 0 ? Math.max(...activities.map(d => d.end_time)) : 0;

            // Initialize timing references when we first get data
            useEffect(() => {
                if (activities.length > 0 && visualizationStartTimeRef.current === null) {
                    const now = Date.now() / 1000;
                    visualizationStartTimeRef.current = now;
                    dataStartTimeRef.current = maxTime;
                    totalPausedTimeRef.current = 0;
                }
            }, [activities.length]);

            // Smooth animation loop - runs independently of data updates
            useEffect(() => {
                if (!autoRefresh || activities.length === 0 || visualizationStartTimeRef.current === null || isPaused) {
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                        animationFrameRef.current = null;
                    }
                    return;
                }

                const animate = () => {
                    const now = Date.now() / 1000;
                    const elapsedWallTime = now - visualizationStartTimeRef.current - totalPausedTimeRef.current;

                    // Current time = where data started + how much wall time has passed
                    const newCurrentTime = dataStartTimeRef.current + elapsedWallTime;

                    setCurrentTime(newCurrentTime);
                    animationFrameRef.current = requestAnimationFrame(animate);
                };

                animationFrameRef.current = requestAnimationFrame(animate);

                return () => {
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                };
            }, [autoRefresh, activities.length, isPaused]);

            const getFileType = (metadata) => {
                if (typeof metadata === 'object' && metadata !== null) {
                    return metadata.file_type || metadata.hotkey?.substring(0, 8) || 'unknown';
                }
                const match = String(metadata).match(/'file_type':\s*'([^']+)'/);
                return match ? match[1] : 'unknown';
            };

            const functionColors = {
                'initiate_activation_upload': '#d1d5db',
                'upload_multipart_to_s3': '#9ca3af',
                'forward': '#6b7280',
                'backward': '#4b5563',
                'compute_loss': '#374151',
                'get_activation_sleep': '#1f2937',
                'default': '#6b7280',
            };

            const visibleStart = currentTime - windowSize;
            const visibleEnd = currentTime;

            const visibleData = activities.filter(d =>
                (d.start_time <= visibleEnd && d.end_time >= visibleStart)
            );

            // Group activities by event name for row assignment
            // Use timerNames to create fixed row assignments so rows don't jump around
            const eventTypeToRow = React.useMemo(() => {
                const typeToRow = {};
                if (timerNames.length > 0) {
                    // Use the predefined timer names for fixed row assignment
                    timerNames.forEach((eventType, idx) => {
                        typeToRow[eventType] = idx;
                    });
                } else {
                    // Fallback to dynamic assignment if timer names aren't loaded yet
                    const uniqueEventTypes = [...new Set(activities.map(a => a.name))];
                    uniqueEventTypes.forEach((eventType, idx) => {
                        typeToRow[eventType] = idx;
                    });
                }
                return typeToRow;
            }, [timerNames, activities]);

            const formatTime = (time) => {
                const relTime = time - minTime;
                return `${relTime.toFixed(2)}s`;
            };

            const formatCurrentTime = (time) => {
                const relTime = time - minTime;
                return `${relTime.toFixed(1)}s`;
            };

            const handleHotkeyChange = (e) => {
                setSelectedHotkey(e.target.value);
                setCurrentTime(0);
                setEvents([]);
                setCountLogs([]);
                setIsLoading(true);
                visualizationStartTimeRef.current = null;
                dataStartTimeRef.current = null;
                totalPausedTimeRef.current = 0;
                setIsPaused(false);
            };

            const togglePause = () => {
                if (isPaused) {
                    // Resuming - add the pause duration to total paused time
                    const pauseDuration = (Date.now() / 1000) - pausedAtRef.current;
                    totalPausedTimeRef.current += pauseDuration;
                    setIsPaused(false);
                } else {
                    // Pausing - record when we paused
                    pausedAtRef.current = Date.now() / 1000;
                    setIsPaused(true);
                }
            };

            const handleMouseMove = (e, content) => {
                setTooltip({
                    visible: true,
                    x: e.clientX + 10,
                    y: e.clientY + 10,
                    content: content
                });
            };

            const handleMouseLeave = () => {
                setTooltip({ visible: false, x: 0, y: 0, content: '' });
            };

            if (availableHotkeys.length === 0) {
                return (
                    <div className="w-full h-screen bg-gray-900 text-white p-6 flex items-center justify-center">
                        <div className="text-center">
                            <div className="text-xl mb-2">No miner data available</div>
                            <div className="text-sm text-gray-400 mb-4">Waiting for miners to send data to the API...</div>
                            <div className="text-xs text-gray-500">
                                Make sure miners are running and TimerLogger is sending data to the visualization server
                            </div>
                        </div>
                    </div>
                );
            }

            if (isLoading) {
                return (
                    <div className="w-full h-screen bg-gray-900 text-white p-6 flex items-center justify-center">
                        <div className="text-center">
                            <div className="text-xl mb-2">Loading...</div>
                            <div className="text-sm text-gray-400">Loading data for hotkey {selectedHotkey}</div>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="w-full h-screen bg-gray-900 text-white p-6 flex items-center justify-center">
                        <div className="text-center">
                            <div className="text-xl mb-2 text-gray-300">Error</div>
                            <div className="text-sm text-gray-400">{error}</div>
                            <div className="text-xs text-gray-500 mt-4">Selected hotkey: {selectedHotkey}</div>
                        </div>
                    </div>
                );
            }

            if (activities.length === 0) {
                return (
                    <div className="w-full h-screen bg-gray-900 text-white p-6">
                        <div className="mb-6">
                            <label className="block text-sm mb-2 text-gray-400">Select Miner Hotkey:</label>
                            <select
                                value={selectedHotkey}
                                onChange={handleHotkeyChange}
                                className="px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white"
                            >
                                {availableHotkeys.map(hotkey => (
                                    <option key={hotkey} value={hotkey}>{hotkey}</option>
                                ))}
                            </select>
                        </div>
                        <div className="flex items-center justify-center h-96">
                            <div className="text-center">
                                <div className="text-xl mb-2">No data for hotkey {selectedHotkey}</div>
                                <div className="text-sm text-gray-400">Waiting for complete events (start + end pairs)...</div>
                                <div className="text-xs text-gray-500 mt-2">{events.length} events received</div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="w-full h-screen bg-gray-900 text-white p-6 flex flex-col overflow-auto">
                    {/* Tooltip */}
                    {tooltip.visible && (
                        <div
                            className="fixed bg-gray-800 text-white px-3 py-2 rounded-lg text-sm border border-gray-600 shadow-lg z-50 pointer-events-none"
                            style={{ left: tooltip.x, top: tooltip.y }}
                        >
                            {tooltip.content}
                        </div>
                    )}

                    <div className="mb-6">
                        <div className="flex justify-between items-start mb-4">
                            <div className="flex items-center space-x-4">
                                <div className="flex flex-col">
                                    <label className="text-xs mb-1 text-gray-400">Miner Hotkey:</label>
                                    <select
                                        value={selectedHotkey}
                                        onChange={handleHotkeyChange}
                                        className="px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white"
                                    >
                                        {availableHotkeys.map(hotkey => (
                                            <option key={hotkey} value={hotkey}>{hotkey}</option>
                                        ))}
                                    </select>
                                </div>
                                <div className="flex flex-col">
                                    <label className="text-xs mb-1 text-gray-400">Time Window:</label>
                                    <select
                                        value={windowSize}
                                        onChange={(e) => setWindowSize(Number(e.target.value))}
                                        className="px-4 py-2 bg-gray-800 border border-gray-700 rounded-lg text-white"
                                    >
                                        <option value={10}>10s</option>
                                        <option value={20}>20s</option>
                                        <option value={60}>1min</option>
                                        <option value={600}>10min</option>
                                    </select>
                                </div>
                            </div>
                            <div className="text-right">
                                <div className="text-sm text-gray-300">‚óè Live</div>
                                <div className="text-xs text-gray-400">Last update: {lastUpdate}</div>
                                <div className="text-xs text-gray-400">{activities.length} activities ({events.length} events)</div>
                            </div>
                        </div>
                        <div>
                            <h1 className="text-2xl font-bold mb-2">
                                Activity Timeline - Sliding {windowSize >= 60 ? `${windowSize / 60}min` : `${windowSize}s`} Window
                            </h1>
                            <div className="text-sm text-gray-400">
                                Current Time: {formatCurrentTime(currentTime)} / Latest Data: {formatCurrentTime(maxTime)}
                            </div>
                        </div>
                    </div>

                    {/* Timeline Chart */}
                    {(() => {
                        // Calculate dynamic height based on number of rows
                        const rowCount = timerNames.length > 0 ? timerNames.length : Object.keys(eventTypeToRow).length;
                        const rowHeight = 50;
                        const topPadding = 50;
                        const bottomPadding = 20;
                        const chartHeight = topPadding + (rowCount * rowHeight) + bottomPadding;

                        return (
                            <div className="bg-gray-800 rounded-lg p-4 mb-6">
                                <div className="flex" style={{height: `${chartHeight}px`}}>
                                    {/* Row labels */}
                                    <div className="mr-4" style={{width: '250px'}}>
                                    {(timerNames.length > 0 ? timerNames : Object.keys(eventTypeToRow)).map((eventType, idx) => {
                                        const rowIdx = eventTypeToRow[eventType] !== undefined ? eventTypeToRow[eventType] : idx;
                                        return (
                                            <div
                                                key={eventType}
                                                className="flex items-center text-sm font-semibold"
                                                style={{
                                                    height: `${rowHeight}px`,
                                                    color: functionColors[eventType] || functionColors.default,
                                                    marginTop: idx === 0 ? `${topPadding}px` : '0',
                                                    opacity: activities.some(a => a.name === eventType) ? 1 : 0.3
                                                }}
                                            >
                                                {eventType}
                                            </div>
                                        );
                                    })}
                                    </div>

                                    <svg width="100%" height="100%" className="overflow-visible" style={{flex: 1}}>
                                        <defs>
                                            <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
                                                <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#374151" strokeWidth="0.5"/>
                                            </pattern>
                                        </defs>

                                        <rect width="100%" height="100%" fill="url(#grid)" />

                                        {visibleData.map((item) => {
                                            const startPos = ((item.start_time - visibleStart) / windowSize) * 100;
                                            const endPos = ((item.end_time - visibleStart) / windowSize) * 100;
                                            const width = endPos - startPos;
                                            const functionName = item.name || 'unknown';
                                            const rowIdx = eventTypeToRow[functionName] || 0;
                                            const y = topPadding + rowIdx * rowHeight;
                                            const fileType = getFileType(item.metadata);
                                            const tooltipText = `${functionName} - ${fileType} - ${item.duration?.toFixed(3) || '?'}s`;

                                            return (
                                                <rect
                                                    key={item.id}
                                                    x={`${startPos}%`}
                                                    y={y}
                                                    width={`${width}%`}
                                                    height="35"
                                                    fill={functionColors[functionName] || functionColors.default}
                                                    opacity="0.8"
                                                    rx="4"
                                                    style={{cursor: 'pointer'}}
                                                    onMouseMove={(e) => handleMouseMove(e, tooltipText)}
                                                    onMouseLeave={handleMouseLeave}
                                                />
                                            );
                                        })}

                                        <line
                                            x1="100%"
                                            y1="0"
                                            x2="100%"
                                            y2="100%"
                                            stroke="#d1d5db"
                                            strokeWidth="2"
                                            opacity="0.8"
                                        />
                                        <text
                                            x="99%"
                                            y="20"
                                            fontSize="12"
                                            fill="#d1d5db"
                                            textAnchor="end"
                                            fontWeight="bold"
                                        >
                                            NOW
                                        </text>

                                        {/* X-axis time labels */}
                                        <text
                                            x="0%"
                                            y="35"
                                            fontSize="11"
                                            fill="#9ca3af"
                                            textAnchor="start"
                                        >
                                            t-{windowSize}s
                                        </text>
                                        <text
                                            x="100%"
                                            y="35"
                                            fontSize="11"
                                            fill="#9ca3af"
                                            textAnchor="end"
                                        >
                                            t-0s
                                        </text>
                                    </svg>
                                </div>
                            </div>
                        );
                    })()}

                    {/* Cumulative Event Counts Line Chart */}
                    {countLogs.length > 0 && (
                        <div className="mt-6 bg-gray-800 rounded-lg p-4">
                            <h2 className="text-xl font-bold mb-4">Cumulative Event Counts Over Time</h2>
                            <svg id="cumulativeChart" width="100%" height="300" className="overflow-visible">
                                <defs>
                                    <pattern id="cumulativeGrid" width="40" height="40" patternUnits="userSpaceOnUse">
                                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#374151" strokeWidth="0.5"/>
                                    </pattern>
                                </defs>

                                <rect width="100%" height="100%" fill="url(#cumulativeGrid)" />

                                {(() => {
                                    // Filter count logs to the visible time window
                                    const visibleCountLogs = countLogs.filter(log =>
                                        log.timestamp >= visibleStart && log.timestamp <= visibleEnd
                                    );

                                    if (visibleCountLogs.length === 0) {
                                        return (
                                            <text
                                                x="50%"
                                                y="50%"
                                                fontSize="14"
                                                fill="#9ca3af"
                                                textAnchor="middle"
                                            >
                                                No data in current time window
                                            </text>
                                        );
                                    }

                                    // Use the visible time window
                                    const timeRange = visibleEnd - visibleStart;

                                    // Collect all unique event types
                                    const eventTypes = new Set();
                                    visibleCountLogs.forEach(log => {
                                        Object.keys(log.event_counts || {}).forEach(type => eventTypes.add(type));
                                    });

                                    // Find max cumulative count for scaling
                                    const maxCumulativeCount = Math.max(...visibleCountLogs.map(log =>
                                        Math.max(...Object.values(log.event_counts || {}))
                                    ));

                                    const chartHeight = 250;
                                    const padding = { top: 20, right: 10, bottom: 30, left: 50 };

                                    // Color palette for different event types (grayscale)
                                    const colors = [
                                        '#d1d5db', '#9ca3af', '#6b7280', '#4b5563',
                                        '#374151', '#1f2937', '#e5e7eb', '#f3f4f6'
                                    ];

                                    // Get actual SVG width for calculations
                                    const svgElement = document.querySelector('#cumulativeChart');
                                    const svgWidth = svgElement?.clientWidth || 1000;
                                    const chartWidth = svgWidth - padding.left - padding.right;

                                    return (
                                        <g>
                                            {/* Y-axis labels */}
                                            {[0, 0.25, 0.5, 0.75, 1].map(fraction => {
                                                const count = Math.round(maxCumulativeCount * fraction);
                                                const y = padding.top + (chartHeight - padding.top - padding.bottom) * (1 - fraction);
                                                return (
                                                    <g key={fraction}>
                                                        <line
                                                            x1={padding.left}
                                                            y1={y}
                                                            x2={svgWidth - padding.right}
                                                            y2={y}
                                                            stroke="#374151"
                                                            strokeWidth="1"
                                                            opacity="0.3"
                                                        />
                                                        <text
                                                            x={padding.left - 5}
                                                            y={y + 4}
                                                            fontSize="10"
                                                            fill="#9ca3af"
                                                            textAnchor="end"
                                                        >
                                                            {count}
                                                        </text>
                                                    </g>
                                                );
                                            })}

                                            {/* Draw lines for each event type */}
                                            {Array.from(eventTypes).map((eventType, typeIdx) => {
                                                const color = colors[typeIdx % colors.length];

                                                const points = visibleCountLogs.map(log => {
                                                    const x = padding.left + ((log.timestamp - visibleStart) / timeRange) * chartWidth;
                                                    const count = log.event_counts?.[eventType] || 0;
                                                    const y = padding.top + (chartHeight - padding.top - padding.bottom) * (1 - count / maxCumulativeCount);
                                                    return { x, y, count };
                                                }).filter(p => p.count > 0);

                                                if (points.length === 0) return null;

                                                const pathData = points.map((p, i) =>
                                                    `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
                                                ).join(' ');

                                                return (
                                                    <g key={eventType}>
                                                        <path
                                                            d={pathData}
                                                            stroke={color}
                                                            strokeWidth="2"
                                                            fill="none"
                                                            opacity="0.8"
                                                            style={{cursor: 'pointer'}}
                                                            onMouseMove={(e) => handleMouseMove(e, eventType)}
                                                            onMouseLeave={handleMouseLeave}
                                                        />
                                                        {/* Draw points */}
                                                        {points.map((p, i) => (
                                                            <circle
                                                                key={i}
                                                                cx={p.x}
                                                                cy={p.y}
                                                                r="3"
                                                                fill={color}
                                                                opacity="0.9"
                                                                style={{cursor: 'pointer'}}
                                                                onMouseMove={(e) => handleMouseMove(e, `${eventType}: ${p.count}`)}
                                                                onMouseLeave={handleMouseLeave}
                                                            />
                                                        ))}
                                                    </g>
                                                );
                                            })}

                                            {/* Current time indicator */}
                                            <line
                                                x1={svgWidth - padding.right}
                                                y1={padding.top}
                                                x2={svgWidth - padding.right}
                                                y2={chartHeight - padding.bottom}
                                                stroke="#d1d5db"
                                                strokeWidth="2"
                                                opacity="0.8"
                                            />

                                            {/* X-axis time labels */}
                                            <text
                                                x={padding.left}
                                                y={chartHeight - 5}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="start"
                                            >
                                                t-{windowSize >= 60 ? `${windowSize / 60}min` : `${windowSize}s`}
                                            </text>
                                            <text
                                                x={svgWidth - padding.right}
                                                y={chartHeight - 5}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="end"
                                            >
                                                t-0s
                                            </text>

                                            {/* Y-axis label */}
                                            <text
                                                x="10"
                                                y={chartHeight / 2}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="middle"
                                                transform={`rotate(-90, 10, ${chartHeight / 2})`}
                                            >
                                                Cumulative Count
                                            </text>
                                        </g>
                                    );
                                })()}
                            </svg>

                            {/* Legend for cumulative count chart */}
                            <div className="mt-4 flex flex-wrap gap-3 text-xs">
                                {(() => {
                                    const eventTypes = new Set();
                                    countLogs.forEach(log => {
                                        Object.keys(log.event_counts || {}).forEach(type => eventTypes.add(type));
                                    });
                                    const colors = [
                                        '#d1d5db', '#9ca3af', '#6b7280', '#4b5563',
                                        '#374151', '#1f2937', '#e5e7eb', '#f3f4f6'
                                    ];
                                    return Array.from(eventTypes).map((eventType, idx) => (
                                        <div key={eventType} className="flex items-center space-x-2">
                                            <div className="w-3 h-3 rounded-full" style={{backgroundColor: colors[idx % colors.length]}}></div>
                                            <span>{eventType}</span>
                                        </div>
                                    ));
                                })()}
                            </div>
                        </div>
                    )}

                    {/* Event Rate Chart */}
                    {countLogs.length > 1 && (
                        <div className="mt-6 bg-gray-800 rounded-lg p-4">
                            <h2 className="text-xl font-bold mb-4">Event Rate Over Time (Events per Interval)</h2>
                            <svg id="rateChart" width="100%" height="300" className="overflow-visible">
                                <defs>
                                    <pattern id="rateGrid" width="40" height="40" patternUnits="userSpaceOnUse">
                                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#374151" strokeWidth="0.5"/>
                                    </pattern>
                                </defs>

                                <rect width="100%" height="100%" fill="url(#rateGrid)" />

                                {(() => {
                                    // Calculate rate data by taking differences between consecutive cumulative counts
                                    // Use the visible time window
                                    const timeRange = visibleEnd - visibleStart;

                                    // Collect all unique event types
                                    const eventTypes = new Set();
                                    countLogs.forEach(log => {
                                        Object.keys(log.event_counts || {}).forEach(type => eventTypes.add(type));
                                    });

                                    // Calculate rates for each event type
                                    const rateCounts = {};
                                    Array.from(eventTypes).forEach(eventType => {
                                        rateCounts[eventType] = [];
                                        for (let i = 1; i < countLogs.length; i++) {
                                            const prevCount = countLogs[i - 1].event_counts?.[eventType] || 0;
                                            const currCount = countLogs[i].event_counts?.[eventType] || 0;
                                            const rate = currCount - prevCount;
                                            rateCounts[eventType].push({
                                                timestamp: countLogs[i].timestamp,
                                                rate: rate
                                            });
                                        }
                                    });

                                    // Filter to visible time window
                                    const visibleRateCounts = {};
                                    Array.from(eventTypes).forEach(eventType => {
                                        visibleRateCounts[eventType] = rateCounts[eventType].filter(data =>
                                            data.timestamp >= visibleStart && data.timestamp <= visibleEnd
                                        );
                                    });

                                    // Check if we have any visible data
                                    const hasVisibleData = Object.values(visibleRateCounts).some(rates => rates.length > 0);

                                    if (!hasVisibleData) {
                                        return (
                                            <text
                                                x="50%"
                                                y="50%"
                                                fontSize="14"
                                                fill="#9ca3af"
                                                textAnchor="middle"
                                            >
                                                No data in current time window
                                            </text>
                                        );
                                    }

                                    // Find max rate for scaling
                                    const maxRate = Math.max(...Object.values(visibleRateCounts).map(rates =>
                                        rates.length > 0 ? Math.max(...rates.map(r => r.rate)) : 0
                                    ));

                                    const chartHeight = 250;
                                    const padding = { top: 20, right: 10, bottom: 30, left: 50 };

                                    // Color palette for different event types (grayscale)
                                    const colors = [
                                        '#d1d5db', '#9ca3af', '#6b7280', '#4b5563',
                                        '#374151', '#1f2937', '#e5e7eb', '#f3f4f6'
                                    ];

                                    // Get actual SVG width for calculations
                                    const svgElement = document.querySelector('#rateChart');
                                    const svgWidth = svgElement?.clientWidth || 1000;
                                    const chartWidth = svgWidth - padding.left - padding.right;

                                    return (
                                        <g>
                                            {/* Y-axis labels */}
                                            {[0, 0.25, 0.5, 0.75, 1].map(fraction => {
                                                const rate = Math.round(maxRate * fraction);
                                                const y = padding.top + (chartHeight - padding.top - padding.bottom) * (1 - fraction);
                                                return (
                                                    <g key={fraction}>
                                                        <line
                                                            x1={padding.left}
                                                            y1={y}
                                                            x2={svgWidth - padding.right}
                                                            y2={y}
                                                            stroke="#374151"
                                                            strokeWidth="1"
                                                            opacity="0.3"
                                                        />
                                                        <text
                                                            x={padding.left - 5}
                                                            y={y + 4}
                                                            fontSize="10"
                                                            fill="#9ca3af"
                                                            textAnchor="end"
                                                        >
                                                            {rate}
                                                        </text>
                                                    </g>
                                                );
                                            })}

                                            {/* Draw lines for each event type */}
                                            {Array.from(eventTypes).map((eventType, typeIdx) => {
                                                const color = colors[typeIdx % colors.length];
                                                const rateData = visibleRateCounts[eventType];

                                                const points = rateData.map(data => {
                                                    const x = padding.left + ((data.timestamp - visibleStart) / timeRange) * chartWidth;
                                                    const y = padding.top + (chartHeight - padding.top - padding.bottom) * (1 - data.rate / maxRate);
                                                    return { x, y, rate: data.rate };
                                                });

                                                if (points.length === 0) return null;

                                                const pathData = points.map((p, i) =>
                                                    `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
                                                ).join(' ');

                                                return (
                                                    <g key={eventType}>
                                                        <path
                                                            d={pathData}
                                                            stroke={color}
                                                            strokeWidth="2"
                                                            fill="none"
                                                            opacity="0.8"
                                                            style={{cursor: 'pointer'}}
                                                            onMouseMove={(e) => handleMouseMove(e, eventType)}
                                                            onMouseLeave={handleMouseLeave}
                                                        />
                                                        {/* Draw points */}
                                                        {points.map((p, i) => (
                                                            <circle
                                                                key={i}
                                                                cx={p.x}
                                                                cy={p.y}
                                                                r="3"
                                                                fill={color}
                                                                opacity="0.9"
                                                                style={{cursor: 'pointer'}}
                                                                onMouseMove={(e) => handleMouseMove(e, `${eventType}: ${p.rate} events`)}
                                                                onMouseLeave={handleMouseLeave}
                                                            />
                                                        ))}
                                                    </g>
                                                );
                                            })}

                                            {/* Current time indicator */}
                                            <line
                                                x1={svgWidth - padding.right}
                                                y1={padding.top}
                                                x2={svgWidth - padding.right}
                                                y2={chartHeight - padding.bottom}
                                                stroke="#d1d5db"
                                                strokeWidth="2"
                                                opacity="0.8"
                                            />

                                            {/* X-axis time labels */}
                                            <text
                                                x={padding.left}
                                                y={chartHeight - 5}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="start"
                                            >
                                                t-{windowSize >= 60 ? `${windowSize / 60}min` : `${windowSize}s`}
                                            </text>
                                            <text
                                                x={svgWidth - padding.right}
                                                y={chartHeight - 5}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="end"
                                            >
                                                t-0s
                                            </text>

                                            {/* Y-axis label */}
                                            <text
                                                x="10"
                                                y={chartHeight / 2}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="middle"
                                                transform={`rotate(-90, 10, ${chartHeight / 2})`}
                                            >
                                                Events per Interval
                                            </text>
                                        </g>
                                    );
                                })()}
                            </svg>

                            {/* Legend for rate chart */}
                            <div className="mt-4 flex flex-wrap gap-3 text-xs">
                                {(() => {
                                    const eventTypes = new Set();
                                    countLogs.forEach(log => {
                                        Object.keys(log.event_counts || {}).forEach(type => eventTypes.add(type));
                                    });
                                    const colors = [
                                        '#d1d5db', '#9ca3af', '#6b7280', '#4b5563',
                                        '#374151', '#1f2937', '#e5e7eb', '#f3f4f6'
                                    ];
                                    return Array.from(eventTypes).map((eventType, idx) => (
                                        <div key={eventType} className="flex items-center space-x-2">
                                            <div className="w-3 h-3 rounded-full" style={{backgroundColor: colors[idx % colors.length]}}></div>
                                            <span>{eventType}</span>
                                        </div>
                                    ));
                                })()}
                            </div>
                        </div>
                    )}

                    {/* RAM/VRAM Usage Chart */}
                    {events.length > 0 && (
                        <div className="bg-gray-800 rounded-lg p-4 mb-6">
                            <h2 className="text-xl font-bold mb-4">Memory Usage Over Time</h2>
                            <svg id="memoryChart" width="100%" height="300" className="overflow-visible">
                                <defs>
                                    <pattern id="memoryGrid" width="40" height="40" patternUnits="userSpaceOnUse">
                                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#374151" strokeWidth="0.5"/>
                                    </pattern>
                                </defs>

                                <rect width="100%" height="100%" fill="url(#memoryGrid)" />

                                {(() => {
                                    // Extract memory data from events, filtering to visible time window
                                    const memoryData = events
                                        .filter(event => event.memory && Object.keys(event.memory).length > 0)
                                        .filter(event => event.time >= visibleStart && event.time <= visibleEnd)
                                        .map(event => ({
                                            time: event.time,
                                            vram_allocated: event.memory.vram_allocated_gb || 0,
                                            vram_reserved: event.memory.vram_reserved_gb || 0,
                                            mps_allocated: event.memory.mps_allocated_gb || 0,
                                            cpu_ram: event.memory.cpu_ram_gb || 0
                                        }))
                                        .sort((a, b) => a.time - b.time);

                                    if (memoryData.length === 0) {
                                        return (
                                            <text
                                                x="50%"
                                                y="50%"
                                                fontSize="14"
                                                fill="#9ca3af"
                                                textAnchor="middle"
                                            >
                                                No memory data in current time window
                                            </text>
                                        );
                                    }

                                    // Determine which memory type we have
                                    const hasVRAM = memoryData.some(d => d.vram_allocated > 0 || d.vram_reserved > 0);
                                    const hasMPS = memoryData.some(d => d.mps_allocated > 0);
                                    const hasCPU = memoryData.some(d => d.cpu_ram > 0);

                                    const timeRange = visibleEnd - visibleStart;

                                    // Find max memory for scaling across ALL available memory types
                                    let maxMemory = 0;
                                    const maxValues = [];
                                    if (hasVRAM) {
                                        maxValues.push(Math.max(...memoryData.map(d => Math.max(d.vram_allocated, d.vram_reserved))));
                                    }
                                    if (hasMPS) {
                                        maxValues.push(Math.max(...memoryData.map(d => d.mps_allocated)));
                                    }
                                    if (hasCPU) {
                                        maxValues.push(Math.max(...memoryData.map(d => d.cpu_ram)));
                                    }
                                    maxMemory = maxValues.length > 0 ? Math.max(...maxValues) : 0;

                                    if (maxMemory === 0) {
                                        return (
                                            <text
                                                x="50%"
                                                y="50%"
                                                fontSize="14"
                                                fill="#9ca3af"
                                                textAnchor="middle"
                                            >
                                                No memory data in current time window
                                            </text>
                                        );
                                    }

                                    const chartHeight = 250;
                                    const padding = { top: 20, right: 10, bottom: 30, left: 50 };

                                    // Get actual SVG width for calculations
                                    const svgElement = document.querySelector('#memoryChart');
                                    const svgWidth = svgElement?.clientWidth || 1000;
                                    const chartWidth = svgWidth - padding.left - padding.right;

                                    // Colors for different memory types
                                    const colors = {
                                        vram_allocated: '#3b82f6',  // blue
                                        vram_reserved: '#8b5cf6',   // purple
                                        mps_allocated: '#10b981',   // green
                                        cpu_ram: '#f59e0b'          // amber
                                    };

                                    // Helper function to create points
                                    const createPoints = (getValue) => {
                                        return memoryData.map(d => {
                                            const value = getValue(d);
                                            const x = padding.left + ((d.time - visibleStart) / timeRange) * chartWidth;
                                            const y = padding.top + (chartHeight - padding.top - padding.bottom) * (1 - value / maxMemory);
                                            return { x, y, value };
                                        });
                                    };

                                    // Helper function to render a line
                                    const renderLine = (points, color, label, key) => {
                                        const validPoints = points.filter(p => p.value > 0);
                                        if (validPoints.length === 0) return null;

                                        const pathData = validPoints.map((p, i) =>
                                            `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
                                        ).join(' ');

                                        return (
                                            <g key={key}>
                                                <path
                                                    d={pathData}
                                                    stroke={color}
                                                    strokeWidth="2"
                                                    fill="none"
                                                    opacity="0.8"
                                                    style={{cursor: 'pointer'}}
                                                    onMouseMove={(e) => handleMouseMove(e, label)}
                                                    onMouseLeave={handleMouseLeave}
                                                />
                                                {validPoints.map((p, i) => (
                                                    <circle
                                                        key={i}
                                                        cx={p.x}
                                                        cy={p.y}
                                                        r="2"
                                                        fill={color}
                                                        opacity="0.9"
                                                        style={{cursor: 'pointer'}}
                                                        onMouseMove={(e) => handleMouseMove(e, `${label}: ${p.value.toFixed(4)} GB`)}
                                                        onMouseLeave={handleMouseLeave}
                                                    />
                                                ))}
                                            </g>
                                        );
                                    };

                                    return (
                                        <g>
                                            {/* Y-axis labels */}
                                            {[0, 0.25, 0.5, 0.75, 1].map(fraction => {
                                                const memValue = (maxMemory * fraction).toFixed(1);
                                                const y = padding.top + (chartHeight - padding.top - padding.bottom) * (1 - fraction);
                                                return (
                                                    <g key={fraction}>
                                                        <line
                                                            x1={padding.left}
                                                            y1={y}
                                                            x2={svgWidth - padding.right}
                                                            y2={y}
                                                            stroke="#374151"
                                                            strokeWidth="1"
                                                            opacity="0.3"
                                                        />
                                                        <text
                                                            x={padding.left - 5}
                                                            y={y + 4}
                                                            fontSize="10"
                                                            fill="#9ca3af"
                                                            textAnchor="end"
                                                        >
                                                            {memValue} GB
                                                        </text>
                                                    </g>
                                                );
                                            })}

                                            {/* Render memory lines based on what's available */}
                                            {hasVRAM && renderLine(
                                                createPoints(d => d.vram_reserved),
                                                colors.vram_reserved,
                                                'VRAM Reserved',
                                                'vram_reserved'
                                            )}
                                            {hasVRAM && renderLine(
                                                createPoints(d => d.vram_allocated),
                                                colors.vram_allocated,
                                                'VRAM Allocated',
                                                'vram_allocated'
                                            )}
                                            {hasMPS && renderLine(
                                                createPoints(d => d.mps_allocated),
                                                colors.mps_allocated,
                                                'MPS Allocated',
                                                'mps_allocated'
                                            )}
                                            {hasCPU && renderLine(
                                                createPoints(d => d.cpu_ram),
                                                colors.cpu_ram,
                                                'CPU RAM',
                                                'cpu_ram_gb'
                                            )}

                                            {/* Current time indicator */}
                                            <line
                                                x1={svgWidth - padding.right}
                                                y1={padding.top}
                                                x2={svgWidth - padding.right}
                                                y2={chartHeight - padding.bottom}
                                                stroke="#d1d5db"
                                                strokeWidth="2"
                                                opacity="0.8"
                                            />

                                            {/* X-axis time labels */}
                                            <text
                                                x={padding.left}
                                                y={chartHeight - 5}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="start"
                                            >
                                                t-{windowSize >= 60 ? `${windowSize / 60}min` : `${windowSize}s`}
                                            </text>
                                            <text
                                                x={svgWidth - padding.right}
                                                y={chartHeight - 5}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="end"
                                            >
                                                t-0s
                                            </text>

                                            {/* Y-axis label */}
                                            <text
                                                x="10"
                                                y={chartHeight / 2}
                                                fontSize="11"
                                                fill="#9ca3af"
                                                textAnchor="middle"
                                                transform={`rotate(-90, 10, ${chartHeight / 2})`}
                                            >
                                                Memory Usage (GB)
                                            </text>
                                        </g>
                                    );
                                })()}
                            </svg>

                            {/* Legend for memory chart - dynamically show what's available */}
                            <div className="mt-4 flex flex-wrap gap-3 text-xs">
                                {(() => {
                                    const memoryData = events.filter(event => event.memory && Object.keys(event.memory).length > 0);
                                    const hasVRAM = memoryData.some(e => (e.memory.vram_allocated_gb || 0) > 0 || (e.memory.vram_reserved_gb || 0) > 0);
                                    const hasMPS = memoryData.some(e => (e.memory.mps_allocated_gb || 0) > 0);
                                    const hasCPU = memoryData.some(e => (e.memory.cpu_ram_gb || 0) > 0);

                                    return (
                                        <>
                                            {hasVRAM && (
                                                <>
                                                    <div className="flex items-center space-x-2">
                                                        <div className="w-3 h-3 rounded-full" style={{backgroundColor: '#3b82f6'}}></div>
                                                        <span>VRAM Allocated</span>
                                                    </div>
                                                    <div className="flex items-center space-x-2">
                                                        <div className="w-3 h-3 rounded-full" style={{backgroundColor: '#8b5cf6'}}></div>
                                                        <span>VRAM Reserved</span>
                                                    </div>
                                                </>
                                            )}
                                            {hasMPS && (
                                                <div className="flex items-center space-x-2">
                                                    <div className="w-3 h-3 rounded-full" style={{backgroundColor: '#10b981'}}></div>
                                                    <span>MPS Allocated</span>
                                                </div>
                                            )}
                                            {hasCPU && (
                                                <div className="flex items-center space-x-2">
                                                    <div className="w-3 h-3 rounded-full" style={{backgroundColor: '#f59e0b'}}></div>
                                                    <span>CPU RAM</span>
                                                </div>
                                            )}
                                        </>
                                    );
                                })()}
                            </div>
                        </div>
                    )}

                    {/* Legend for timeline */}
                    <div className="bg-gray-800 rounded-lg p-4">
                        <h3 className="text-lg font-bold mb-3">Function Legend</h3>
                        <div className="flex flex-wrap gap-4 text-sm">
                            {Object.entries(functionColors).filter(([func]) => func !== 'default').map(([func, color]) => (
                                <div key={func} className="flex items-center space-x-2">
                                    <div className="w-4 h-4 rounded" style={{backgroundColor: color}}></div>
                                    <span>{func}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<GanttChart />, document.getElementById('root'));
    </script>
</body>
</html>
